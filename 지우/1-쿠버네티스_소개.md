# 1장: 쿠버네티스 소개

---

## 1.1 쿠버네티스 등장배경

> _Monolith → MicroService_

- 서버 배포 스케줄링, 관리, 장애 처리를 자동화하는 것의 필요성 대두
- 모놀리식 애플리케이션을 마이크로서비스로 세분화하면서 애플리케이션의 개발과 배포 방식도 변화

### Monolith vs MicroService

| Monolith                                       | MicroService                                                                          |
| ---------------------------------------------- | ------------------------------------------------------------------------------------- |
| 하나의 OS 프로세스로 실행                      | 독립적인 프로세스                                                                     |
| 일부 변경 시 애플리케이션 재배포               | 일부 변경 시에도 재배포 필요 X                                                        |
| 상호의존성이 높음                              | 특정 개발 언어에 종속 X                                                               |
| 복잡성 증가, 품질 저하                         | 개별적 개발과 배포 가능                                                               |
| 일부 수평확장이 어려움 ⇒ 전체 시스템 함께 확장 | 필요한 서비스 별도로 확장 가능 ⇒ 수평/수직 확장 가능                                  |
|                                                | Restful API 제공 HTTP, AMQP 비동기 프로토콜 통신 (최근에는 gRPC, RSocket 통신도 가능) |

### 근데 마이크로서비스도 단점이..?!

- 구성 요소가 많아짐 → 배포 조합 수 증가 → 구성 요소 간 상호종속성 증가
- 여러 서비스가 통신하여 전체 시스템이 하나처럼 동작할 수 있도록 구성해야 함
- 여러 프로세스와 시스템에 분산 → 오류 발생 시 추적의 어려움 (Zipkin; 분산 추적 시스템)
- 동일 서버에서 실행되는 애플리케이션의 종속성 충돌
  - 다른 버전의 동일 라이브러리를 사용하는 경우 구성 요소 간 종속성 차이 발생

### 데브옵스의 등장

**일관된 실행 환경**을 제공하는 것이 중요🌟

⇒ 개발팀이 애플리케이션을 배포하고 관리하는, 즉 개발과 QA, 운영이 전체 프로세스에서 협업하는 데브옵스 문화가 등장!

---

## 1.2 컨테이너 기술과 도커의 등장

각 구성요소에 전용 가상머신을 제공하고 고유 운영체제 인스턴스 제공 → 하드웨어 리소스가 넘쳐난다!

⇒ **리눅스 컨테이너 기술**: 동일 호스트 시스템에서 여러 서비스 실행, 환경 격리하면서 오버헤드를 줄이는 방법

### 컨테이너 vs 가상머신

| 가상머신                                          | 컨테이너                                   |
| ------------------------------------------------- | ------------------------------------------ |
| 애플리케이션 수만큼 분리된 운영체제 실행          | 가상머신보다 가벼움                        |
| 물리적 하드웨어 리소스 요구                       |                                            |
| 자체 리눅스 커널을 실행 → 완전히 격리된 환경 제공 | 모두 동일한 커널 호출 → 보안 위험 가능성 O |

### 컨테이너 격리 메커니즘

1. namespace
   1. 각 프로세스가 시스템(파일, 네트워크 인터페이스, 호스트네임 등)의 독립된 뷰만 볼 수 있도록 해줌
   2. 네임스페이스: 특정 리소스 그룹 격리 기능
2. cgroups (리눅스 컨트롤 그룹)
   1. 프로세스가 사용 가능한 리소스(CPU, 메모리, 네트워크 대역폭 등) 제한

### 도커 등장!

> _애플리케이션을 패키징, 배포, 실행하는 플랫폼_

리눅스 컨테이너 기술로 (가상머신과 거의 동일한 수준의) 격리 환경 제공

1️⃣ **이미지**

- 애플리케이션과 해당 환경 패키지화한 것
- 애플리케이션에서 사용하는 파일시스템, 실행파일 경로 등의 메타데이터 포함

2️⃣ **레지스트리**

- 도커 이미지를 저장하고 이미지를 쉽게 공유할 수 있는 **저장소**
- 이미지 빌드하면서 레지스트리에 **push** & 다른 컴퓨터에서 이미지 **pull**

3️⃣ **컨테이너**

- 도커 컨테이너 이미지에서 생성된 일반적인 리눅스 컨테이너
- 실행 중 프로세스와 호스트의 다른 프로세스 완전 격리, 할당된 리소스 양만 액세스하고 사용

- 도커 이미지 레이어
  **배포 효율성 ⬆️**
  - 이전에 배포한 이미지와 동일한 레이어가 포함돼있으면 재전송할 필요 X → 배포 속도 ⬆️
    **스토리지 공간 ⬇️**
  - 레이어는 동일 호스트에 한 번만 저장
  - 이미지 레이어는 readonly → 컨테이너 실행 시 쓰기 가능한 레이어 생성

### 컨테이너 이미지에도 단점이 있다

커널을 공유 → 다른 버전의 커널로 실행하거나 동일 커널 모듈 사용하지 못하는 경우 애플리케이션 실행 불가

⇒ 여전히 가상머신이 필요함

**그래서 쿠버네티스가 등장!**

---

## 1.3 쿠버네티스

### Overview

> 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할 수 있게 하는 소프트웨어

<aside>
💬 주의! 쿠버네티스는 도커 기반 컨테이너에서만 돌아가는 것이 아니다!
쿠버네티스의 컨테이너 런타임은 도커 외에도 rkt를 지원한다.

**OCI(Open Container Initiative)**; 컨테이너 형식과 런타임에 관한 업계 표준

</aside>

- 클러스터 크기와 상관없이 동일하게 배포
- 클러스터 노드 추가 == 사용가능한 리소스 양이 추가되는 것을 의미

### 쿠버네티스 클러스터 아키텍처

**컨트롤 플레인(Control Plane, master node)**: 클러스터 제어 및 작동

- API 서버: 사용자와 컨트롤 플레인 구성 요소와 통신
- 스케줄러: 애플리케이션 배포, 각 구성요소를 워커 노드에 할당
  - API 서버에게 어떤 노드를 사용할 건지 알려줌
- 컨트롤러 매니저: 구성요소 복제본, 워커노드 추적, 노드 장애처리 등 클러스터단 기능 수행
- etcd: key-value 형식으로 클러스터 구성을 지속적으로 저장하는 분산 데이터 저장소

**노드(Node):** 컨테이너화된 애플리케이션을 실행하는 시스템

- kubelet: API 서버와 통신, 노드의 컨테이너 관리
  - 파드를 관리한다고 생각, 파드에서 컨테이너가 원활히 동작하도록 관리
- Container Runtime (ex. 도커, rkt)
- kube-proxy: 애플리케이션 구성요소 간 네트워크 트래픽을 로드밸런싱하는 프록시
  - 쿠버네티스 서비스의 구현부
  - 내부 네트워크 세션이나 클러스터 외부에서 파드로 통신할 수 있도록 한다.

### 쿠버네티스로 애플리케이션 실행

디스크립터를 쿠버네티스에 제출 → 복제본 수를 사용 가능한 워커 노드에 할당

- 앱 디스크립터 내에 있는 세 개의 컨테이너(마지막은 격리X, 함께 실행) ⇒ **파드(Pod)**
- 컨테이너 앞의 숫자: 병렬로 실행해야 하는 레플리카 수
- 노드의 kubelet: 도커 이미지 레지스트리에서 컨테이너 이미지를 가져와 컨테이너 실행을 지시

### 그리고 장점들

쿠버네티스는 컨테이너를 클러스터 내에서 이동할 수 있다.

- 노드에 문제가 생겼을 시 다시 스케줄링하여 새 노드에 할당

쿠버네티스가 인스턴스 수 조정을 지시할 수 있다 ⇒ Auto Scaling

동일 컨테이너에 대해 하나의 고정 IP 주소 사용

- 클라이언트가 특정 서비스를 제공하는 컨테이너를 쉽게 찾을 수 있도록
- 하나의 고정 IP 주소로 컨테이너 노출, 해당 주소를 실행 중인 모든 애플리케이션에 노출
- 환경변수로 제공 or DNS로 조회

---

## 정리

리눅스 네임스페이스, 리눅스 cgroup로 컨테이너 격리 ⇒ 이 기능을 쉽게 사용할 수 있도록 하는 것이 도커!

여러 소프트웨어 구성요소를 관리하고 큰 규모의 배포 관리를 처리하기 위해 쿠버네티스가 등장

시스템 관리자의 도움 없이 애플리케이션 배포 가능

애플리케이션 개발과 배포 단순화, health check와 자가 치유, autoscaling 등의 장점
